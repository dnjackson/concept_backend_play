---
timestamp: 'Sun Oct 12 2025 00:57:33 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251012_005733.10c0fc31.md]]'
content_id: f5ad9b9229e90706e872e0f1ec7a2f9bbaab36fd139eade5932774325a0a6039
---

# Concept API extraction

You are an expert software architect tasked with generating clear, developer-friendly API documentation. Your input is a formal "Concept Specification" which describes a modular piece of software functionality. This concept has been implemented and exposed as a REST-like API by a "Concept Server."

Your mission is to translate the provided Concept Specification into a structured API specification document written in Markdown. This document will be used by frontend developers to interact with the API.

Adhere to the following rules for the API structure and the documentation format:

**API Structure Rules:**

1. **Base URL:** Assume a base URL of `/api`.
2. **Endpoint Naming:** Each concept action or query maps to an endpoint. The URL structure is: `/{conceptName}/{actionOrQueryName}`.
   * For a concept named `Labeling` and an action `createLabel`, the endpoint is `/api/Labeling/createLabel`.
3. **HTTP Method:** All endpoints use the `POST` method.
4. **Data Format:** All requests and responses use the `application/json` content type.
5. **Request Body:** The request body is always a single JSON object. The keys of this object correspond to the input arguments defined in the action's signature.
6. **Response Body:**
   * **Actions:** A successful call to an action returns a single JSON object. The keys correspond to the results defined in the action's signature. If there are no results, an empty object `{}` is returned.
   * **Queries:** A successful call to a query (a method name starting with `_`) returns a JSON **array** of objects.
   * **Errors:** If an action fails to meet its `requires` condition or encounters another error, it returns a single JSON object with a single key: `{ "error": "A descriptive error message." }`.

**Documentation Format Rules:**

Generate the output in Markdown using the following template. For each action and query in the specification, create a dedicated endpoint section.

````markdown
# API Specification: {Concept Name} Concept

**Purpose:** {The concept's purpose.}

---

## API Endpoints

### POST /api/{conceptName}/{actionName}

**Description:** {A brief, one-sentence description of what this action does.}

**Requirements:**
- {List each point from the 'requires' section of the specification.}

**Effects:**
- {List each point from the 'effects' section of the specification.}

**Request Body:**
```json
{
  "argument1": "{type}",
  "argument2": "{type}"
}
```

**Success Response Body (Action):**
```json
{
  "result1": "{type}",
  "result2": "{type}"
}
```

**Success Response Body (Query):**
```json
[
  {
    "result1": "{type}",
    "result2": "{type}"
  }
]
```

**Error Response Body:**
```json
{
  "error": "string"
}
```
---
*(Repeat for each action and query)*
````

Now, analyze the following Concept Specification and generate the API documentation based on these instructions.

Please extract an API for this concept:

Specification:

**concept** LikertSurvey \[User]

**purpose** understand group sentiment on a set of topics by aggregating quantitative feedback

**principle** if an owner creates a survey with several questions and shares it, and multiple users respond to the questions, then the owner can view an aggregated summary of the responses for each question.

**state**

```
a set of Surveys with
    a title String
    an owner User

a set of Questions with
    a stem String
    a survey Survey  -- Links a question to its parent survey

a set of Responses with
    a responder User
    a question Question
    a choice Number
```

**actions**

createSurvey (title: String, owner: User): (survey: Survey)
**requires** title is non-empty
**effects** creates a new `Survey` with the given title and owner and returns it

addQuestion (stem: String, survey: Survey): (question: Question)
**requires** stem is non-empty and survey exists
**effects** creates a new `Question` with the given stem, associates it with the given survey, and returns it

removeQuestion (question: Question)
**requires** question exists
**effects** removes the specified question and all `Response` entities associated with it

respondToQuestion (question: Question, responder: User, choice: Number)
**requires**

* question exists
* choice is an integer between 1 and 5
  **effects**
* delete any existing response to this question
* creates a new `Response` linking the responder, question, and choice

**queries**

\_getSurveyQuestions (survey: Survey): (questions: set of Question)
**requires** survey exists
**effects** returns the set of all Questions where `Question.survey` is the given survey

\_getQuestionResults (question: Question): (results: map of Number to Number)
**requires** question exists
**effects** returns a map where each key is a choice value (e.g., 1-5) and its value is the count of Responses for this question with that choice

\_analyzeSentiment (question: Question): (sentiment: String)
**effects**
This query analyzes all responses for a given `question` and returns a string indicating the overall sentiment. The logic is as follows:

1. Collect the `score` from every `Response` where the `question` matches the input `question`.
2. If there are no responses, return "neutral".
3. Calculate the average and standard deviation of all collected scores.
4. Return a sentiment string based on these rules:
   * If the average score is greater than 3.5, return "positive".
   * If the average score is less than 2.5, return "negative".
   * If the standard deviation is greater than 1.5 (indicating a high degree of variance and polarization), return "bimodal".
   * Otherwise, return "mixed".

\_getSurveyQuestions (survey: Survey): (questions: set of Question)
**requires** the given survey exists
**effects** returns the set of all `Question` entities whose `survey` field matches the input `survey`

\_getQuestionResponseCounts (question: Question): (counts: array of Number)
**requires** the given question exists
**effects** returns an array of counts of responses by choice number (that is, the nth element is the number of responses with choice n+1)

\_getUserSurveys (user: User): (surveys: set of Survey)
**requires** the given user exists
**effects** returns the set of all `Survey` entities where the `owner` field matches the input `user`

Code:
